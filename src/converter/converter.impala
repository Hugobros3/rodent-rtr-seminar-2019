struct ConverterInputTriMesh {
    indices: &[i32], // Should be a Buffer eventually (to support non-cpu devices)
    tri_count: i32,
    vertices: &[f32],
}

struct OutputNode8Tri4 {
    nodes_count: i32,
    nodes: &[Node8],
    tris_count: i32,
    tris: &[Tri4],
}

// todo reorganize impala files so these definitions aren't duplicated
struct Tri4 {
    v0: [[f32 * 4] * 3],
    e1: [[f32 * 4] * 3],
    e2: [[f32 * 4] * 3],
    n:  [[f32 * 4] * 3],
    prim_id: [i32 * 4],
    geom_id: [i32 * 4]
}

struct Node4 {
    bounds: [[f32 * 4] * 6],
    child:   [i32 * 4],
    pad:     [i32 * 4]
}

struct Node8 {
    bounds: [[f32 * 8] * 6],
    child:   [i32 * 8],
    pad:     [i32 * 8]
}

struct Tri {
    v0: Vec3,
    v1: Vec3,
    v2: Vec3,
}

// seems like there is a glitch when two array pointers exist in the same struct, I just end up reading garbage when I use ConverterInputTriMesh
// unless I remove one array pointer field then it works fine.

// extern fn make_bvh8_4(input_data: ConverterInputTriMesh) -> OutputNode8Tri4 {

extern fn make_bvh8_4(pc: i32, ind: &[i32], vd: &[f32]) -> OutputNode8Tri4 {

    let input_data = ConverterInputTriMesh {
        indices: ind,
        tri_count: pc,
        vertices: vd,
    };

    fn @load_indices(t: i32) -> (i32, i32, i32, i32) {
        let o = t * 4;
        let i = input_data.indices(o + 0);
        let j = input_data.indices(o + 1);
        let k = input_data.indices(o + 2);
        let m = input_data.indices(o + 3);
        (i, j, k, m)
    }

    fn @load_vertex(i: i32) -> Vec3 {
        make_vec3 (
            input_data.vertices(i * 3 + 0),
            input_data.vertices(i * 3 + 1),
            input_data.vertices(i * 3 + 2),
        )
    }

    fn @load_tri(i: i32) -> Tri {
        let (i0, i1, i2, _) = load_indices(i);
        Tri {
            v0: load_vertex(i0),
            v1: load_vertex(i1),
            v2: load_vertex(i2),
        }
    }

    fn @tri_bbox(tri: Tri) -> BBox {
        let min = vec3_min(tri.v0, vec3_min(tri.v1, tri.v2));
        let max = vec3_max(tri.v0, vec3_max(tri.v1, tri.v2));
        make_bbox(min, max)
    }

    fn @tri_center(tri: Tri) -> Vec3 {
        vec3_mulf(vec3_add(tri.v0, vec3_add(tri.v1, tri.v2)), 0.3333333f)
    }

    let input = Input {
        primitives_count: pc,
        bboxes: @ | i | { @@tri_bbox(load_tri(i)) },
        centers: @ | i | { @@tri_center(load_tri(i)) },
    };

    //todo some good heuristic for sizing those
    let nodes_buffer = alloc_cpu(sizeof[Node8]() * 655360);
    let tris_buffer = alloc_cpu(sizeof[Tri4]() * 655360);

    let nodes = nodes_buffer.data as &mut[Node8];
    let tris = tris_buffer.data as &mut[Tri4];

    let mut nodes_count = 0;
    let mut tris_count = 0;

    let max_primitive_packet_size = 4;

    let output_writer = OutputWriter {
        arity: 8,

        write_inner_node: @ | node_id, bbox, child_count, children_ids, children_bboxes | {
            nodes_count++;

            fn @select_bbox_component(c: i32, bbox: &BBox) -> f32 {
                match(c) {
                    0 => bbox.min.x,
                    2 => bbox.min.y,
                    4 => bbox.min.z,
                    1 => bbox.max.x,
                    3 => bbox.max.y,
                    5 => bbox.max.z,
                    _ => -1f,
                }
            }
            fn @bbox_component_or_minus_zero(c: i32, i: i32) -> f32 { if i >= child_count { 0f } else { select_bbox_component(c, children_bboxes(i)) }}

            fn @fill_bbox_component(c: i32, data: &mut[f32 * 8]) -> () {
                for i in range(0, 8) {
                    data(i) = bbox_component_or_minus_zero(c, i);
                }
            }

            for i in range(0, 6) {
                fill_bbox_component(i, &mut nodes(node_id).bounds(i));
            }

            fn @child_id_or_zero(i: i32) -> i32 { if i >= child_count { 0 } else { children_ids(i) }}
            for i in range(0, 8) {
                nodes(node_id).child(i) = child_id_or_zero(i);
            }

            node_id + 1
        },
        write_leaf_node: @ | bbox, prim_offset, prim_count| {
            let base_primitive_id = tris_count;

            let mut t = prim_offset;
            let end = prim_offset + prim_count;

            while t < end {
                let packet_size = cpu_intrinsics.min(max_primitive_packet_size, end - t);

                let id = tris_count++;

                fn @spread_and_set(vec3: Vec3, place: i32, target: &mut[[f32 * 4] * 3]) -> () {
                    target(0)(place) = vec3.x;
                    target(1)(place) = vec3.y;
                    target(2)(place) = vec3.z;
                }

                for i in range(0, packet_size) {
                    let tri = load_tri(t);
                    let v0 = tri.v0;
                    let e1 = vec3_sub(tri.v0, tri.v1); // v0 - v1
                    let e2 = vec3_sub(tri.v2, tri.v0); // v2 - v0
                    let n = vec3_cross(e1, e2);

                    let (_, _, _, m) = load_indices(t);

                    spread_and_set(v0, i, &mut tris(id).v0);
                    spread_and_set(e1, i, &mut tris(id).e1);
                    spread_and_set(e2, i, &mut tris(id).e2);
                    spread_and_set(n, i, &mut tris(id).n);

                    tris(id).prim_id(i) = t;
                    tris(id).geom_id(i) = m;

                    t++;
                }

                for i in range(packet_size, max_primitive_packet_size) {
                    tris(id).prim_id(i) = -1;
                    tris(id).geom_id(i) = -1;
                }
            }

            base_primitive_id ^ bitcast[i32](0xFFFFFFFFu32)
        },
    };

    build_bvh(input, output_writer);

    OutputNode8Tri4 {
        nodes_count: nodes_count,
        nodes: nodes,
        tris_count: tris_count,
        tris: tris,
    }
}